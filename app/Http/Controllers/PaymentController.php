<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use phpseclib\Crypt\RSA;
use Illuminate\Support\Facades\Log;

class PaymentController extends Controller
{
    protected $baseUrl;
    protected $fabricAppId;
    protected $appSecret;
    protected $merchantAppId;
    protected $merchantCode;
    protected $privateKey;

    public function __construct()
    {
        $this->baseUrl = env('BASE_URL');
        $this->fabricAppId = env('FABRIC_APP_ID');
        $this->appSecret = env('APP_SECRET');
        $this->merchantAppId = env('MERCHANT_APP_ID');
        $this->merchantCode = env('MERCHANT_CODE');
        $this->privateKey = env('PRIVATE_KEY');

        // Log configuration for debugging
        Log::info('PaymentController initialized with config:', [
            'baseUrl' => $this->baseUrl,
            'fabricAppId' => $this->fabricAppId,
            'merchantAppId' => $this->merchantAppId,
            'merchantCode' => $this->merchantCode,
        ]);
    }

    /**
     * Apply fabric token generated by et-server
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function applyFabricToken()
    {
        $ch = curl_init();

        $headers = [
            "Content-Type: application/json",
            "X-APP-Key: " . $this->fabricAppId
        ];

        $url = $this->baseUrl . "/payment/v1/token";
        $payload = [
            "appSecret" => $this->appSecret
        ];
        $data = json_encode($payload);

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For dev environment only
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For dev environment only
        curl_setopt($ch, CURLOPT_TIMEOUT, 30);

        $authToken = curl_exec($ch);
        $curlError = curl_error($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        if ($curlError) {
            Log::error('cURL error in applyFabricToken', [
                'url' => $url,
                'error' => $curlError,
                'http_code' => $httpCode
            ]);
            curl_close($ch);
            return response()->json(['error' => 'cURL error: ' . $curlError], 500);
        }

        curl_close($ch);

        $response = json_decode($authToken, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            Log::error('Invalid JSON response in applyFabricToken', [
                'url' => $url,
                'raw_response' => $authToken,
                'json_error' => json_last_error_msg()
            ]);
            return response()->json(['error' => 'Invalid response from payment gateway'], 500);
        }

        if (!isset($response['token'])) {
            Log::error('Token not found in applyFabricToken response', [
                'url' => $url,
                'response' => $response
            ]);
            return response()->json(['error' => 'Failed to obtain auth token', 'details' => $response], 500);
        }

        Log::info('Successfully obtained auth token', ['token' => $response['token']]);
        return response()->json($response);
    }

    /**
     * Generate RSA signature of data
     *
     * @param string $data
     * @return string|null
     */
    private function signWithRSA($data)
    {
        $rsa = new RSA();
        $privateKey = $this->trimPrivateKey($this->privateKey)[2];

        if (!$rsa->loadKey($privateKey)) {
            Log::error('Failed to load private key for signing', ['data' => $data]);
            return null;
        }

        $rsa->setHash("sha256");
        $rsa->setMGFHash("sha256");

        $signatureByte = $rsa->sign($data);
        $signature = base64_encode($signatureByte);

        Log::info('Generated RSA signature', ['data' => $data, 'signature' => $signature]);
        return $signature;
    }

    /**
     * Trim the private key
     *
     * @param string $stringData
     * @return array
     */
    private function trimPrivateKey($stringData)
    {
        return explode("-----", $stringData);
    }

    /**
     * Sort string for signing
     *
     * @param string $stringApplet
     * @return string
     */
    private function sortedString($stringApplet)
    {
        $stringExplode = '';
        $sortedArray = explode("&", $stringApplet);
        sort($sortedArray);
        foreach ($sortedArray as $x_value) {
            $stringExplode .= ($stringExplode == '') ? $x_value : '&' . $x_value;
        }

        return $stringExplode;
    }

    /**
     * Sign request data
     *
     * @param array $request
     * @return string|null
     */
    private function sign($request)
    {
        $excludeFields = ["sign", "sign_type", "header", "refund_info", "openType", "raw_request"];
        $data = $request;
        ksort($data);
        $stringApplet = '';

        foreach ($data as $key => $values) {
            if (in_array($key, $excludeFields)) {
                continue;
            }

            if ($key == "biz_content") {
                foreach ($values as $value => $singleValue) {
                    $stringApplet .= ($stringApplet == '') ? "$value=$singleValue" : "&$value=$singleValue";
                }
            } else {
                $stringApplet .= ($stringApplet == '') ? "$key=$values" : "&$key=$values";
            }
        }

        $sortedString = $this->sortedString($stringApplet);
        return $this->signWithRSA($sortedString);
    }

    /**
     * Generate unique merchant order ID
     *
     * @return string
     */
    private function createMerchantOrderId()
    {
        return (string) time();
    }

    /**
     * Generate timestamp
     *
     * @return string
     */
    private function createTimeStamp()
    {
        return (string) time();
    }

    /**
     * Generate a 32-length random string
     *
     * @return string
     */
    private function createNonceStr()
    {
        $chars = [
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
            "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"
        ];
        $str = "";
        for ($i = 0; $i < 32; $i++) {
            $index = rand(0, 35);
            $str .= $chars[$index];
        }
        return $str;
    }

    /**
     * Handle payment request
     *
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function processPayment(Request $request)
    {
        // Validate incoming request
        $validated = $request->validate([
            'amount' => 'required|numeric|min:0.01',
            'enterprise_id' => 'required|numeric',
            // 'currency' => 'required|string',
            'description' => 'required|string',
        ]);

        // Get auth token
        $tokenResponse = $this->applyFabricToken();
        $tokenData = json_decode($tokenResponse->getContent(), true);

        if (isset($tokenData['error']) || !isset($tokenData['token'])) {
            Log::error('Failed to obtain auth token in processPayment', ['response' => $tokenData]);
            return response()->json(['error' => 'Failed to obtain auth token', 'details' => $tokenData], 500);
        }

        $authToken = $tokenData['token'];

        // Prepare payment request
        $bizContent = [
            'amount' => $validated['amount'],
            'enterprise_id' => $validated['enterprise_id'],
            // 'currency' => $validated['currency'],
            'description' => $validated['description'],
            'merchantOrderId' => $this->createMerchantOrderId(),
        ];
        dd($bizContent);

        $payload = [
            'appId' => $this->merchantAppId,
            'merchantCode' => $this->merchantCode,
            'nonceStr' => $this->createNonceStr(),
            'timestamp' => $this->createTimeStamp(),
            'biz_content' => $bizContent,
            'sign_type' => 'RSA256',
        ];

        // Generate signature
        $payload['sign'] = $this->sign($payload);

        // Make payment request
        $ch = curl_init();

        $headers = [
            "Content-Type: application/json",
            "Authorization: Bearer " . $authToken,
            "X-APP-Key: " . $this->fabricAppId
        ];

        $url = $this->baseUrl . "/payment/v1/process";
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // For dev environment only
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // For dev environment only
        curl_setopt($ch, CURLOPT_TIMEOUT, 30);

        $response = curl_exec($ch);
        $curlError = curl_error($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        if ($curlError) {
            Log::error('cURL error in processPayment', [
                'url' => $url,
                'error' => $curlError,
                'http_code' => $httpCode,
                'payload' => $payload
            ]);
            curl_close($ch);
            return response()->json(['error' => 'cURL error: ' . $curlError], 500);
        }

        curl_close($ch);

        $paymentResponse = json_decode($response, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            Log::error('Invalid JSON response in processPayment', [
                'url' => $url,
                'raw_response' => $response,
                'json_error' => json_last_error_msg()
            ]);
            return response()->json(['error' => 'Invalid response from payment gateway'], 500);
        }

        Log::info('Payment response received', ['response' => $paymentResponse]);
        return response()->json($paymentResponse);
    }
}